<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Assignment Method Example</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>Assignment Method Example</h1><br/><div class="codebox">//Assume&nbsp;that&nbsp;the&nbsp;string&nbsp;class&nbsp;does&nbsp;not&nbsp;exist&nbsp;yet<br />class&nbsp;String{<br />	public:<br />		String(const&nbsp;char*&nbsp;value=&quot;&quot;);&nbsp;//Default&nbsp;value&nbsp;for&nbsp;constructor&nbsp;(can&nbsp;leave&nbsp;off&nbsp;argument)<br />		String(const&nbsp;String&amp;&nbsp;other);&nbsp;//Must&nbsp;be&nbsp;passed&nbsp;by&nbsp;reference,&nbsp;not&nbsp;value<br />		String&amp;&nbsp;operator=(const&nbsp;String&amp;&nbsp;rhs);&nbsp;<br />		String();<br />		~String();<br />		void&nbsp;swap(String&amp;&nbsp;other);<br />	&nbsp;<br />	private:<br />		//char&nbsp;m_text[100];&nbsp;does&nbsp;not&nbsp;support&nbsp;longer&nbsp;strings,&nbsp;inefficient&nbsp;on&nbsp;small&nbsp;strings<br />		char*&nbsp;m_text;<br />		int&nbsp;m_len;<br />};<br /><br />void&nbsp;String::swap(String&amp;&nbsp;other){<br />	//Swaps&nbsp;m_test&nbsp;and&nbsp;other.m_text<br />	//Swaps&nbsp;m_len&nbsp;and&nbsp;other.m_len<br />}<br /><br />String::String(const&nbsp;char*&nbsp;value){&nbsp;//Copy&nbsp;constructor<br />	if(value==nullptr)&nbsp;<br />		value=&quot;&quot;;<br />	//m_text=value;&nbsp;Problem:&nbsp;keeps&nbsp;the&nbsp;same&nbsp;array&nbsp;in&nbsp;the&nbsp;main&nbsp;method&nbsp;(must&nbsp;create&nbsp;copy)<br />	m_len=strlen(value);<br />	m_text=new&nbsp;char[m_len+1];<br />	strcpy(m_text,value);<br />}<br />String::String(const&nbsp;String&amp;&nbsp;other){<br />	m_len=other.m_len;<br />	m_text=new&nbsp;char[m_len+1];<br />	strcpy(m_text,other.m_text);&nbsp;//Can&nbsp;access&nbsp;private&nbsp;members&nbsp;of&nbsp;any&nbsp;string<br />}<br />String::~String(){<br />	//delete&nbsp;m_text;&nbsp;Wrong,&nbsp;must&nbsp;use&nbsp;array&nbsp;form&nbsp;of&nbsp;delete<br />	delete&nbsp;[]&nbsp;m_text;<br />}<br /><br />String&amp;&nbsp;String::operator=(const&nbsp;String&amp;&nbsp;rhs)<br />{<br />	if(this!=&amp;rhs){&nbsp;//Check&nbsp;for&nbsp;self-assignment<br />	<br />		/**Traditional&nbsp;method:&nbsp;<br />		delete&nbsp;[]&nbsp;m_text;&nbsp;//Stops&nbsp;memory&nbsp;leak,&nbsp;but&nbsp;cannot&nbsp;delete&nbsp;at&nbsp;start&nbsp;because&nbsp;will&nbsp;lose&nbsp;data&nbsp;(on&nbsp;self-assignment)<br />		m_len=rhs.m_len;&nbsp;&nbsp;<br />		m_text=new&nbsp;char[m_len+1];&nbsp;//Problem:&nbsp;if&nbsp;memory&nbsp;allocation&nbsp;fails&nbsp;and&nbsp;exception&nbsp;thrown,&nbsp;should&nbsp;leave&nbsp;data&nbsp;unchanged<br />		strcpy(m_text,rhs.m_text);&nbsp;<br />		**/<br />		//Modern&nbsp;way:<br />		String&nbsp;temp(rhs);<br />		swap(temp);<br />	}<br /><br />	return&nbsp;*this;<br />}</div></div></body></html>